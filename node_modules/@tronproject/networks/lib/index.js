"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNetwork = void 0;
var logger_1 = require("@tronproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
;
function isRenetworkable(value) {
    return (value && typeof (value.renetwork) === "function");
}
// function ethDefaultProvider(network: string | Network): Renetworkable {
//     const func = function(providers: any, options?: any): any {
//         if (options == null) { options = { }; }
//         const providerList: Array<any> = [];
// 
//         if (providers.InfuraProvider) {
//             try {
//                 providerList.push(new providers.InfuraProvider(network, options.infura));
//             } catch(error) { }
//         }
// 
//         if (providers.EtherscanProvider) {
//             try {
//                 providerList.push(new providers.EtherscanProvider(network, options.etherscan));
//             } catch(error) { }
//         }
// 
//         if (providers.AlchemyProvider) {
//             try {
//                 providerList.push(new providers.AlchemyProvider(network, options.alchemy));
//             } catch(error) { }
//         }
// 
//         /*
//         if (providers.PocketProvider) {
//             // These networks are currently faulty on Pocket as their
//             // network does not handle the Berlin hardfork, which is
//             // live on these ones.
//             // @TODO: This goes away once Pocket has upgraded their nodes
//             const skip = [ "goerli", "ropsten", "rinkeby" ];
//             try {
//                 const provider = new providers.PocketProvider(network);
//                 if (provider.network && skip.indexOf(provider.network.name) === -1) {
//                     providerList.push(provider);
//                 }
//             } catch(error) { }
//         }
//         */
// 
//         if (providers.CloudflareProvider) {
//             try {
//                 providerList.push(new providers.CloudflareProvider(network));
//             } catch(error) { }
//         }
// 
//         if (providerList.length === 0) { return null; }
// 
//         if (providers.FallbackProvider) {
//             let quorum = 1;
//             if (options.quorum != null) {
//                 quorum = options.quorum;
//             } else if (network === "homestead") {
//                 quorum = 2;
//             }
//             return new providers.FallbackProvider(providerList, quorum);
//         }
// 
//         return providerList[0];
//     };
// 
//     func.renetwork = function(network: Network) {
//         return ethDefaultProvider(network);
//     };
// 
//     return func;
// }
// function etcDefaultProvider(url: string, network: string | Network): Renetworkable {
//     const func = function(providers: any, options?: any): any {
//         if (providers.JsonRpcProvider) {
//             return new providers.JsonRpcProvider(url, network);
//         }
// 
//         return null;
//     };
// 
//     func.renetwork = function(network: Network) {
//         return etcDefaultProvider(url, network);
//     };
// 
//     return func;
// }
// 
// const homestead: Network = {
//     chainId: 1,
//     ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
//     name: "homestead",
//     _defaultProvider: ethDefaultProvider("homestead")
// };
// 
// const ropsten: Network = {
//     chainId: 3,
//     ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
//     name: "ropsten",
//     _defaultProvider: ethDefaultProvider("ropsten")
// };
// 
// const classicMordor: Network = {
//     chainId: 63,
//     name: "classicMordor",
//     _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
// };
var networks = {
    unspecified: { chainId: 0, name: "unspecified" },
    //     homestead: homestead,
    //     mainnet: homestead,
    // 
    //     morden: { chainId: 2, name: "morden" },
    // 
    //     ropsten: ropsten,
    //     testnet: ropsten,
    // 
    //     rinkeby: {
    //         chainId: 4,
    //         ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    //         name: "rinkeby",
    //         _defaultProvider: ethDefaultProvider("rinkeby")
    //     },
    // 
    //     kovan: {
    //         chainId: 42,
    //         name: "kovan",
    //         _defaultProvider: ethDefaultProvider("kovan")
    //     },
    // 
    //     goerli: {
    //         chainId: 5,
    //         ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    //         name: "goerli",
    //         _defaultProvider: ethDefaultProvider("goerli")
    //      },
    // 
    // 
    //     // ETC (See: #351)
    //     classic: {
    //         chainId: 61,
    //         name: "classic",
    //         _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/etc", "classic")
    //     },
    // 
    //     classicMorden: { chainId: 62, name: "classicMorden" },
    // 
    //     classicMordor: classicMordor,
    //     classicTestnet: classicMordor,
    // 
    //     classicKotti: {
    //         chainId: 6,
    //         name: "classicKotti",
    //         _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/kotti", "classicKotti")
    //     },
    // 
    //     xdai: { chainId: 100, name: "xdai" },
    // 
    //     matic: { chainId: 137, name: "matic" },
    //     maticmum: { chainId: 80001, name: "maticmum" },
    // 
    //     bnb: { chainId: 56, name: "bnb" },
    //     bnbt: { chainId: 97, name: "bnbt" },
    mainnet: { chainId: "0x2b6653dc", name: "mainnet" },
    nile: { chainId: "0xcd8690dc", name: "nile" },
    shasta: { chainId: "0x94a9059e", name: "shasta" },
};
/**
 *  getNetwork
 *
 *  Converts a named common networks or chain ID (network ID) to a Network
 *  and verifies a network is a valid Network..
 */
function getNetwork(network) {
    // No network (null)
    if (network == null) {
        return null;
    }
    if (typeof (network) === "number" || typeof (network) === 'string') {
        for (var name_1 in networks) {
            var standard_1 = networks[name_1];
            if (standard_1.chainId === network) {
                return {
                    name: standard_1.name,
                    chainId: standard_1.chainId,
                    ensAddress: (standard_1.ensAddress || null),
                    _defaultProvider: (standard_1._defaultProvider || null)
                };
            }
        }
        return {
            chainId: network,
            name: "unknown"
        };
    }
    if (typeof (network) === "string") {
        var standard_2 = networks[network];
        if (standard_2 == null) {
            return null;
        }
        return {
            name: standard_2.name,
            chainId: standard_2.chainId,
            ensAddress: standard_2.ensAddress,
            _defaultProvider: (standard_2._defaultProvider || null)
        };
    }
    var standard = networks[network.name];
    // Not a standard network; check that it is a valid network in general
    if (!standard) {
        if (typeof (network.chainId) !== "number" || typeof (network.chainId) !== 'string') {
            logger.throwArgumentError("invalid network chainId", "network", network);
        }
        return network;
    }
    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)
    if (network.chainId !== 0 && network.chainId !== standard.chainId) {
        logger.throwArgumentError("network chainId mismatch", "network", network);
    }
    // @TODO: In the next major version add an attach function to a defaultProvider
    // class and move the _defaultProvider internal to this file (extend Network)
    var defaultProvider = network._defaultProvider || null;
    if (defaultProvider == null && standard._defaultProvider) {
        if (isRenetworkable(standard._defaultProvider)) {
            defaultProvider = standard._defaultProvider.renetwork(network);
        }
        else {
            defaultProvider = standard._defaultProvider;
        }
    }
    // Standard Network (allow overriding the ENS address)
    return {
        name: network.name,
        chainId: standard.chainId,
        ensAddress: (network.ensAddress || standard.ensAddress || null),
        _defaultProvider: defaultProvider
    };
}
exports.getNetwork = getNetwork;
//# sourceMappingURL=index.js.map