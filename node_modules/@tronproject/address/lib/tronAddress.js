"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA256 = exports.byte2hexStr = exports.byteArray2hexStr = exports.hexChar2byte = exports.getBase58CheckAddress = exports.isAddressValid = exports.decodeBase58Address = exports.toTronAddress = exports.toHexAddress = exports.isTronAddress = void 0;
var sha2_1 = require("@tronproject/sha2");
var bytes_1 = require("@tronproject/bytes");
var basex_1 = require("@tronproject/basex");
var ADDRESS_SIZE = 34;
var ADDRESS_PREFIX_BYTE = 0x41;
function isTronAddress(address) {
    // Convert HEX to Base58
    try {
        return isAddressValid(getBase58CheckAddress(bytes_1.arrayify(address.replace(/^0x/, '0x41'))));
    }
    catch (err) {
        return false;
    }
}
exports.isTronAddress = isTronAddress;
function toHexAddress(address) {
    return bytes_1.hexlify(decodeBase58Address(address)).replace(/^(0x)?41/, "0x");
    ;
}
exports.toHexAddress = toHexAddress;
function toTronAddress(address) {
    return getBase58CheckAddress(bytes_1.arrayify(address.replace(/^0x/, '0x41')));
}
exports.toTronAddress = toTronAddress;
function decodeBase58Address(base58String) {
    if (typeof (base58String) != 'string')
        return [];
    if (base58String.length <= 4)
        return [];
    var address = basex_1.Base58.decode(base58String);
    var len = address.length;
    var offset = len - 4;
    var checkSum = address.slice(offset);
    address = address.slice(0, offset);
    var hash0 = SHA256(address);
    var hash1 = SHA256(hash0);
    var checkSum1 = hash1.slice(0, 4);
    if (checkSum[0] == checkSum1[0] && checkSum[1] == checkSum1[1] && checkSum[2] ==
        checkSum1[2] && checkSum[3] == checkSum1[3]) {
        return address;
    }
    throw new Error('Invalid address provided');
}
exports.decodeBase58Address = decodeBase58Address;
function isAddressValid(base58Str) {
    if (typeof base58Str !== 'string')
        return false;
    if (base58Str.length !== ADDRESS_SIZE)
        return false;
    var address = basex_1.Base58.decode(base58Str);
    if (address.length !== 25)
        return false;
    if (address[0] !== ADDRESS_PREFIX_BYTE)
        return false;
    var checkSum = address.slice(21);
    address = address.slice(0, 21);
    var hash0 = SHA256(address);
    var hash1 = SHA256(hash0);
    var checkSum1 = hash1.slice(0, 4);
    if (checkSum[0] == checkSum1[0] &&
        checkSum[1] == checkSum1[1] &&
        checkSum[2] == checkSum1[2] &&
        checkSum[3] == checkSum1[3]) {
        return true;
    }
    return false;
}
exports.isAddressValid = isAddressValid;
function getBase58CheckAddress(addressBytes) {
    var hash0 = SHA256(addressBytes);
    var hash1 = SHA256(hash0);
    var checkSum = hash1.slice(0, 4);
    var a = bytes_1.concat([addressBytes, checkSum]);
    return basex_1.Base58.encode(a);
}
exports.getBase58CheckAddress = getBase58CheckAddress;
function hexChar2byte(c) {
    var d;
    if (c >= 'A' && c <= 'F')
        d = c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
    else if (c >= 'a' && c <= 'f')
        d = c.charCodeAt(0) - 'a'.charCodeAt(0) + 10;
    else if (c >= '0' && c <= '9')
        d = c.charCodeAt(0) - '0'.charCodeAt(0);
    if (typeof d === 'number')
        return d;
    else
        throw new Error('The passed hex char is not a valid hex char');
}
exports.hexChar2byte = hexChar2byte;
function byteArray2hexStr(byteArray) {
    var str = '';
    for (var i = 0; i < byteArray.length; i++)
        str += byte2hexStr(byteArray[i]);
    return str;
}
exports.byteArray2hexStr = byteArray2hexStr;
function byte2hexStr(byte) {
    if (typeof byte !== 'number')
        throw new Error('Input must be a number');
    if (byte < 0 || byte > 255)
        throw new Error('Input must be a byte');
    var hexByteMap = '0123456789ABCDEF';
    var str = '';
    str += hexByteMap.charAt(byte >> 4);
    str += hexByteMap.charAt(byte & 0x0f);
    return str;
}
exports.byte2hexStr = byte2hexStr;
function SHA256(msgBytes) {
    var msgHex = byteArray2hexStr(msgBytes);
    var hashHex = sha2_1.sha256('0x' + msgHex);
    return bytes_1.arrayify(hashHex);
}
exports.SHA256 = SHA256;
//# sourceMappingURL=tronAddress.js.map