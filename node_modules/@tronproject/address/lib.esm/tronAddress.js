import { sha256 } from '@tronproject/sha2';
import { arrayify, concat, hexlify } from '@tronproject/bytes';
import { Base58 } from '@tronproject/basex';
const ADDRESS_SIZE = 34;
const ADDRESS_PREFIX_BYTE = 0x41;
export function isTronAddress(address) {
    // Convert HEX to Base58
    try {
        return isAddressValid(getBase58CheckAddress(arrayify(address.replace(/^0x/, '0x41'))));
    }
    catch (err) {
        return false;
    }
}
export function toHexAddress(address) {
    return hexlify(decodeBase58Address(address)).replace(/^(0x)?41/, "0x");
    ;
}
export function toTronAddress(address) {
    return getBase58CheckAddress(arrayify(address.replace(/^0x/, '0x41')));
}
export function decodeBase58Address(base58String) {
    if (typeof (base58String) != 'string')
        return [];
    if (base58String.length <= 4)
        return [];
    let address = Base58.decode(base58String);
    const len = address.length;
    const offset = len - 4;
    const checkSum = address.slice(offset);
    address = address.slice(0, offset);
    const hash0 = SHA256(address);
    const hash1 = SHA256(hash0);
    const checkSum1 = hash1.slice(0, 4);
    if (checkSum[0] == checkSum1[0] && checkSum[1] == checkSum1[1] && checkSum[2] ==
        checkSum1[2] && checkSum[3] == checkSum1[3]) {
        return address;
    }
    throw new Error('Invalid address provided');
}
export function isAddressValid(base58Str) {
    if (typeof base58Str !== 'string')
        return false;
    if (base58Str.length !== ADDRESS_SIZE)
        return false;
    let address = Base58.decode(base58Str);
    if (address.length !== 25)
        return false;
    if (address[0] !== ADDRESS_PREFIX_BYTE)
        return false;
    const checkSum = address.slice(21);
    address = address.slice(0, 21);
    const hash0 = SHA256(address);
    const hash1 = SHA256(hash0);
    const checkSum1 = hash1.slice(0, 4);
    if (checkSum[0] == checkSum1[0] &&
        checkSum[1] == checkSum1[1] &&
        checkSum[2] == checkSum1[2] &&
        checkSum[3] == checkSum1[3]) {
        return true;
    }
    return false;
}
export function getBase58CheckAddress(addressBytes) {
    const hash0 = SHA256(addressBytes);
    const hash1 = SHA256(hash0);
    let checkSum = hash1.slice(0, 4);
    let a = concat([addressBytes, checkSum]);
    return Base58.encode(a);
}
export function hexChar2byte(c) {
    let d;
    if (c >= 'A' && c <= 'F')
        d = c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
    else if (c >= 'a' && c <= 'f')
        d = c.charCodeAt(0) - 'a'.charCodeAt(0) + 10;
    else if (c >= '0' && c <= '9')
        d = c.charCodeAt(0) - '0'.charCodeAt(0);
    if (typeof d === 'number')
        return d;
    else
        throw new Error('The passed hex char is not a valid hex char');
}
export function byteArray2hexStr(byteArray) {
    let str = '';
    for (let i = 0; i < byteArray.length; i++)
        str += byte2hexStr(byteArray[i]);
    return str;
}
export function byte2hexStr(byte) {
    if (typeof byte !== 'number')
        throw new Error('Input must be a number');
    if (byte < 0 || byte > 255)
        throw new Error('Input must be a byte');
    const hexByteMap = '0123456789ABCDEF';
    let str = '';
    str += hexByteMap.charAt(byte >> 4);
    str += hexByteMap.charAt(byte & 0x0f);
    return str;
}
export function SHA256(msgBytes) {
    const msgHex = byteArray2hexStr(msgBytes);
    const hashHex = sha256('0x' + msgHex);
    return arrayify(hashHex);
}
//# sourceMappingURL=tronAddress.js.map