"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Logger } from "@tronproject/logger";
import { version } from "./_version";
import { fetchJson } from "@tronproject/web";
import { StaticJsonRpcProvider } from "./url-json-rpc-provider";
import { defineReadOnly } from "@tronproject/properties";
import { isAddress, getAddress } from "@tronproject/address";
import { BigNumber } from "@tronproject/bignumber";
import { toUtf8String } from "@tronproject/strings";
import { shallowCopy } from "@tronproject/properties";
const logger = new Logger(version);
export class JsonRpcProvider extends StaticJsonRpcProvider {
    constructor(url, options = { strict: true }, network) {
        const originUrl = typeof (url) === 'object' ? shallowCopy(url) : url;
        if (options && options.strict) {
            if (typeof (url) === 'object') {
                url.url = url.url + '/jsonrpc';
                url.fullHost = url.fullHost ? url.fullHost : url.url;
            }
            else {
                url = url + '/jsonrpc';
            }
        }
        super(url, network);
        defineReadOnly(this, "_fullNode", originUrl);
        defineReadOnly(this, "_isTron", true);
    }
    tronSend(method, request) {
        const connection = typeof (this._fullNode) === 'object' ? Object.assign(Object.assign({}, this._fullNode), { url: this._fullNode.fullHost + method }) : this._fullNode + method;
        const result = fetchJson(connection, JSON.stringify(request)).then((result) => {
            this.emit("debug", {
                action: "response",
                request: request,
                response: result,
                provider: this
            });
            return result;
        }, (error) => {
            this.emit("debug", {
                action: "response",
                error: error,
                request: request,
                provider: this
            });
            throw error;
        });
        return result;
    }
    paramsNotValid(params) {
        const isNotNullOrUndefined = (val) => {
            return val !== null && typeof val !== 'undefined';
        };
        const isArray = (array) => {
            return Array.isArray(array);
        };
        const isBoolean = (bool) => {
            return typeof bool === 'boolean';
        };
        const isString = (string) => {
            return typeof string === 'string';
        };
        const isHex = (string) => {
            if (string === '0x')
                return true;
            return (typeof string === 'string'
                && !isNaN(parseInt(string, 16))
                && /^(0x|)[a-fA-F0-9]+$/.test(string));
        };
        const isInteger = (number) => {
            if (number === null)
                return false;
            return Number.isInteger(Number(number));
        };
        const throwInvalid = (param) => {
            logger.throwError(`Invalid ${param.name}${param.type === 'address' ? ' address' : ''} provided`, Logger.errors.INVALID_ARGUMENT);
        };
        let no = false;
        for (const param of params) {
            const { value, type, gt, lt, gte, lte, optional } = param;
            if (optional && !isNotNullOrUndefined(value))
                continue;
            switch (type) {
                case 'address':
                    if (!isAddress(value)) {
                        no = true;
                    }
                    break;
                case 'integer':
                    if (!isInteger(value) ||
                        (typeof gt === 'number' && value <= param.gt) ||
                        (typeof lt === 'number' && value >= param.lt) ||
                        (typeof gte === 'number' && value < param.gte) ||
                        (typeof lte === 'number' && value > param.lte)) {
                        no = true;
                    }
                    break;
                case 'hex':
                    if (!isHex(value)) {
                        no = true;
                    }
                    break;
                case 'array':
                    if (!isArray(value)) {
                        no = true;
                    }
                    break;
                case 'not-empty-string':
                    if (!isString(value) || !value.length) {
                        no = true;
                    }
                    break;
                case 'boolean':
                    if (!isBoolean(value)) {
                        no = true;
                    }
                    break;
                case 'string':
                    if (!isString(value) ||
                        (typeof gt === 'number' && value.length <= param.gt) ||
                        (typeof lt === 'number' && value.length >= param.lt) ||
                        (typeof gte === 'number' && value.length < param.gte) ||
                        (typeof lte === 'number' && value.length > param.lte)) {
                        no = true;
                    }
                    break;
            }
            if (no) {
                throwInvalid(param);
                return true;
            }
        }
        return false;
    }
    _getMethod(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (transaction.to) {
                const code = yield this.getCode(transaction.to);
                if (code != '0x') {
                    return 'triggerSmartContract';
                }
                else {
                    return 'createTransaction';
                }
            }
            else {
                return 'deployContract';
            }
        });
    }
    buildTronTransaction(transaction) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.paramsNotValid([
                {
                    name: 'from',
                    type: 'address',
                    value: transaction.from
                },
                {
                    name: 'to',
                    type: 'address',
                    value: transaction.to,
                    optional: true
                },
                {
                    name: 'gas',
                    type: 'integer',
                    value: transaction.gas,
                    gte: 0,
                    optional: true
                },
                {
                    name: 'value',
                    type: 'integer',
                    value: transaction.value,
                    gte: 0,
                    optional: true
                },
                {
                    name: 'consumeUserResourcePercent',
                    type: 'integer',
                    value: transaction.consumeUserResourcePercent,
                    gte: 0,
                    lte: 100,
                    optional: true
                },
                {
                    name: 'originEnergyLimit',
                    type: 'integer',
                    value: transaction.originEnergyLimit,
                    gte: 0,
                    lte: 1e7,
                    optional: true
                },
                {
                    name: 'name',
                    type: 'string',
                    value: transaction.name,
                    optional: true
                },
                {
                    name: 'tokenId',
                    type: 'integer',
                    value: transaction.tokenId,
                    gt: 1000000,
                    optional: true
                },
                {
                    name: 'tokenValue',
                    type: 'integer',
                    value: transaction.tokenValue,
                    gte: 0,
                    optional: true
                },
                {
                    name: 'permissionId',
                    type: 'integer',
                    value: transaction.permissionId,
                    gte: 0,
                    optional: true
                },
                {
                    name: 'abi',
                    type: 'string',
                    value: transaction.abi,
                    optional: true
                }
            ])) {
                return;
            }
            const method = yield this._getMethod(transaction);
            let trans;
            if (method == "deployContract") {
                trans = {
                    from: transaction.from,
                    data: transaction.data,
                    gas: transaction.gas ? BigNumber.from(transaction.gas).toHexString() : '0x0',
                    value: transaction.value ? BigNumber.from(transaction.value).toHexString() : '0x0',
                    consumeUserResourcePercent: (_a = transaction.consumeUserResourcePercent) !== null && _a !== void 0 ? _a : 100,
                    originEnergyLimit: (_b = transaction.originEnergyLimit) !== null && _b !== void 0 ? _b : 100,
                    abi: (_c = transaction.abi) !== null && _c !== void 0 ? _c : '',
                    name: (_d = transaction.name) !== null && _d !== void 0 ? _d : ''
                };
                if (transaction.tokenId) {
                    trans.tokenId = transaction.tokenId;
                }
                if (transaction.tokenValue) {
                    trans.tokenValue = transaction.tokenValue;
                }
            }
            else if (method == 'triggerSmartContract') {
                trans = {
                    from: transaction.from,
                    to: (_e = transaction.to) !== null && _e !== void 0 ? _e : '',
                    data: transaction.data,
                    value: transaction.value ? BigNumber.from(transaction.value).toHexString() : '0x0',
                    gas: transaction.gas ? BigNumber.from(transaction.gas).toHexString() : '0x0',
                };
                if (transaction.tokenId) {
                    trans.tokenId = transaction.tokenId;
                }
                if (transaction.tokenValue) {
                    trans.tokenValue = transaction.tokenValue;
                }
            }
            else if (method == 'createTransaction') {
                trans = {
                    from: transaction.from,
                    to: (_f = transaction.to) !== null && _f !== void 0 ? _f : '',
                    value: transaction.value ? BigNumber.from(transaction.value).toHexString() : '0x0',
                };
                if (transaction.value) {
                    if (transaction.tokenValue) {
                        logger.throwError("Can't send TRX and TRC10 in one transaction", Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "buildTronTransaction"
                        });
                    }
                }
                else {
                    if (transaction.tokenId) {
                        trans.tokenId = transaction.tokenId;
                    }
                    if (transaction.tokenValue) {
                        trans.tokenValue = transaction.tokenValue;
                    }
                }
            }
            else {
                logger.throwError("Can't build transaction", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "buildTronTransaction"
                });
            }
            if (transaction.permissionId) {
                trans.permissionId = transaction.permissionId;
            }
            const request = {
                method: "buildTransaction",
                params: [trans],
                id: this._nextId++,
                jsonrpc: "2.0"
            };
            try {
                const result = yield fetchJson(this.connection, JSON.stringify(request));
                this.emit("debug", {
                    action: "response",
                    request: request,
                    response: result,
                    provider: this
                });
                return result;
            }
            catch (error) {
                this.emit("debug", {
                    action: "response",
                    error: error,
                    request: request,
                    provider: this
                });
                throw error;
            }
        });
    }
    sendTronTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const tx = yield this.tronSend("/wallet/broadcasttransaction", transaction);
                // Check the hash we expect is the same as the hash the server reported
                if (tx != null && tx.code) {
                    logger.throwError("Transaction failed", Logger.errors.UNKNOWN_ERROR, { code: tx.code, message: toUtf8String(`0x${tx.message || ''}`) });
                }
                tx.wait = (confirmations) => { return this.waitForTransaction(`0x${tx.txid}`, confirmations); };
                return tx;
            }
            catch (error) {
                throw error;
            }
        });
    }
    _getAddress(addressOrName) {
        return __awaiter(this, void 0, void 0, function* () {
            addressOrName = yield addressOrName;
            if (addressOrName == null) {
                logger.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: `resolveName(${JSON.stringify(addressOrName)})`
                });
            }
            else if (isAddress(addressOrName)) {
                return getAddress(addressOrName);
            }
            return null;
        });
    }
}
//# sourceMappingURL=tron-json-rpc-provider.js.map