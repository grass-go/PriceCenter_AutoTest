"use strict";

import { Logger } from "@tronproject/logger";
import { version } from "./_version";
import { TronTransactionRequest, TronTransactionResponse } from "@tronproject/abstract-provider";
import { fetchJson, ConnectionInfo } from "@tronproject/web";
import { Networkish } from "@tronproject/networks";
import { StaticJsonRpcProvider } from "./url-json-rpc-provider";
import { defineReadOnly } from "@tronproject/properties";
import { isAddress, getAddress } from "@tronproject/address";
import { BigNumber } from "@tronproject/bignumber";
import { toUtf8String } from "@tronproject/strings";
import { shallowCopy } from "@tronproject/properties";

const logger = new Logger(version);

export type TronTransactionMethods = 'createTransaction' | 'deployContract' | 'triggerSmartContract';

export class JsonRpcProvider extends StaticJsonRpcProvider {

    readonly _fullNode: ConnectionInfo | string;
    readonly _isTron: boolean;


    constructor(url: ConnectionInfo | string, options: any = {strict: true}, network?: Networkish) {
        const originUrl: ConnectionInfo | string = typeof(url) === 'object' ? shallowCopy(url) : url;
        if(options && options.strict) {
            if(typeof(url) === 'object') {
                url.url = url.url + '/jsonrpc';
                url.fullHost = url.fullHost ?  url.fullHost : url.url
            } else {
                url = url + '/jsonrpc';
            }
        }
        super(url, network);

        defineReadOnly(this, "_fullNode", originUrl);
        defineReadOnly(this, "_isTron", true);
    }

    tronSend(method: string, request: any): Promise<any> {
        const connection = typeof(this._fullNode) === 'object' ? { ...this._fullNode, url: this._fullNode.fullHost + method } : this._fullNode + method
        const result = fetchJson(connection, JSON.stringify(request)).then((result) => {
            this.emit("debug", {
                action: "response",
                request: request,
                response: result,
                provider: this
            });

            return result;

        }, (error) => {
            this.emit("debug", {
                action: "response",
                error: error,
                request: request,
                provider: this
            });

            throw error;
        });

        return result;
    }

    paramsNotValid(params: Array<any>): boolean {
        const isNotNullOrUndefined = (val: any) => {
            return val !== null && typeof val !== 'undefined';
        };

        const isArray = (array: Array<any>) => {
            return Array.isArray(array);
        };

        const isBoolean = (bool: boolean) => {
            return typeof bool === 'boolean';
        };

        const isString = (string: string) => {
            return typeof string === 'string';
        };

        const isHex = (string: string) => {
            if (string === '0x') return true;

            return (typeof string === 'string'
                && !isNaN(parseInt(string, 16))
                && /^(0x|)[a-fA-F0-9]+$/.test(string));
        };

        const isInteger = (number: number) => {
            if (number === null)
                return false
            return Number.isInteger(
                Number(number)
            );
        };

        const throwInvalid = (param: any) => {
            logger.throwError(`Invalid ${param.name}${param.type === 'address' ? ' address' : ''} provided`, Logger.errors.INVALID_ARGUMENT);
        }

        let no = false;

        for (const param of params) {
           const {
               value,
               type,
               gt,
               lt,
               gte,
               lte,
               optional
            } = param;
            if (optional && !isNotNullOrUndefined(value))
                continue;
            switch (type) {
                case 'address':
                    if (!isAddress(value)) {
                        no = true;
                    }
                    break;
                case 'integer':
                    if (!isInteger(value) ||
                        (typeof gt === 'number' && value <= param.gt) ||
                        (typeof lt === 'number' && value >= param.lt) ||
                        (typeof gte === 'number' && value < param.gte) ||
                        (typeof lte === 'number' && value > param.lte)) {
                        no = true;
                    }
                    break;
                case 'hex':
                    if (!isHex(value)) {
                        no = true;
                    }
                    break;
                case 'array':
                    if (!isArray(value)) {
                        no = true;
                    }
                    break;
                case 'not-empty-string':
                    if (!isString(value) || !value.length) {
                        no = true;
                    }
                    break;
                case 'boolean':
                    if (!isBoolean(value)) {
                        no = true;
                    }
                    break;
                case 'string':
                    if (!isString(value) ||
                        (typeof gt === 'number' && value.length <= param.gt) ||
                        (typeof lt === 'number' && value.length >= param.lt) ||
                        (typeof gte === 'number' && value.length < param.gte) ||
                        (typeof lte === 'number' && value.length > param.lte)) {
                        no = true;
                    }
                    break;
            }
            if (no) {
                throwInvalid(param);
                return true;
            }
        }
        return false;
    }

    async _getMethod(transaction: any): Promise<TronTransactionMethods> {
        if (transaction.to) {
            const code = await this.getCode(transaction.to);
            if (code != '0x') {
                return 'triggerSmartContract';
            } else {
                return 'createTransaction';
            }
        } else {
            return 'deployContract';
        }
    }

    async buildTronTransaction(transaction: any): Promise<any> {
        if (this.paramsNotValid([
            {
                name: 'from',
                type: 'address',
                value: transaction.from
            },
            {
                name: 'to',
                type: 'address',
                value: transaction.to,
                optional: true
            },
            {
                name: 'gas',
                type: 'integer',
                value: transaction.gas,
                gte: 0,
                optional: true
            },
            {
                name: 'value',
                type: 'integer',
                value: transaction.value,
                gte: 0,
                optional: true
            },
            {
                name: 'consumeUserResourcePercent',
                type: 'integer',
                value: transaction.consumeUserResourcePercent,
                gte: 0,
                lte: 100,
                optional: true
            },
            {
                name: 'originEnergyLimit',
                type: 'integer',
                value: transaction.originEnergyLimit,
                gte: 0,
                lte: 1e7,
                optional: true
            },
            {
                name: 'name',
                type: 'string',
                value: transaction.name,
                optional: true
            },
            {
                name: 'tokenId',
                type: 'integer',
                value: transaction.tokenId,
                gt: 1000000,
                optional: true
            },
            {
                name: 'tokenValue',
                type: 'integer',
                value: transaction.tokenValue,
                gte: 0,
                optional: true
            },
            {
                name: 'permissionId',
                type: 'integer',
                value: transaction.permissionId,
                gte: 0,
                optional: true
            },
            {
                name: 'abi',
                type: 'string',
                value: transaction.abi,
                optional: true
            }
        ])) {
            return;
        }
        const method = await this._getMethod(transaction);

        let trans: any;
        if (method == "deployContract") {
            trans = {
                from: transaction.from,
                data: transaction.data,
                gas: transaction.gas ? BigNumber.from(transaction.gas).toHexString() : '0x0',
                value: transaction.value ? BigNumber.from(transaction.value).toHexString() : '0x0',
                consumeUserResourcePercent: transaction.consumeUserResourcePercent ?? 100,
                originEnergyLimit: transaction.originEnergyLimit ?? 100,
                abi: transaction.abi ?? '',
                name: transaction.name ?? ''
            }

            if (transaction.tokenId) {
                trans.tokenId = transaction.tokenId
            }
            if (transaction.tokenValue) {
                trans.tokenValue = transaction.tokenValue
            }
        } else if (method == 'triggerSmartContract') {
            trans = {
                from: transaction.from,
                to: transaction.to ?? '',
                data: transaction.data,
                value: transaction.value ? BigNumber.from(transaction.value).toHexString() : '0x0',
                gas: transaction.gas ? BigNumber.from(transaction.gas).toHexString() : '0x0',
            }

            if (transaction.tokenId) {
                trans.tokenId = transaction.tokenId
            }
            if (transaction.tokenValue) {
                trans.tokenValue = transaction.tokenValue
            }
        } else if (method == 'createTransaction') {
            trans = {
                from: transaction.from,
                to: transaction.to ?? '',
                value: transaction.value ? BigNumber.from(transaction.value).toHexString() : '0x0',
            }

            if (transaction.value) {
                if (transaction.tokenValue) {
                    logger.throwError("Can't send TRX and TRC10 in one transaction", Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "buildTronTransaction"
                    });
                }
            } else {
                if (transaction.tokenId) {
                    trans.tokenId = transaction.tokenId
                }
                if (transaction.tokenValue) {
                    trans.tokenValue = transaction.tokenValue
                }
            }
        } else {
            logger.throwError("Can't build transaction", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "buildTronTransaction"
            });
        }

        if (transaction.permissionId) {
            trans.permissionId = transaction.permissionId
        }

        const request = {
            method: "buildTransaction",
            params: [trans],
            id: this._nextId++,
            jsonrpc: "2.0"
        }

        try {
            const result = await fetchJson(this.connection, JSON.stringify(request));

            this.emit("debug", {
                action: "response",
                request: request,
                response: result,
                provider: this
            });

            return result
        } catch (error) {
            this.emit("debug", {
                action: "response",
                error: error,
                request: request,
                provider: this
            });

            throw error;
        }
    }

    async sendTronTransaction(transaction: TronTransactionRequest): Promise<TronTransactionResponse> {
        try {
            const tx =  await this.tronSend("/wallet/broadcasttransaction", transaction);

            // Check the hash we expect is the same as the hash the server reported
            if (tx != null && tx.code) {
                logger.throwError("Transaction failed", Logger.errors.UNKNOWN_ERROR, { code: tx.code, message: toUtf8String(`0x${tx.message || ''}`) });
            }

            tx.wait = (confirmations?: number) => { return this.waitForTransaction(`0x${tx.txid}`, confirmations); }

            return tx;
        } catch (error) {
            throw error;
        }
    }

    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {
        addressOrName = await addressOrName;
        if (addressOrName == null) {
            logger.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: `resolveName(${ JSON.stringify(addressOrName) })`
            });
        } else if(isAddress(addressOrName)){
            return getAddress(addressOrName);
        }
        return null;
    }
}

